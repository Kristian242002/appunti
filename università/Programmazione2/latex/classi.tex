\section{Creazione di una Classe}
\subsection{Creazione di una classe e utilizzo}
Creiamo un file Date.java e ci scriviamo il seguente codice :
\begin{lstlisting}[style=java]
public class Date {
    // Attributi
    int day;
    int month;
    int year;
}

\end{lstlisting}
Invece nel file MainDate ci scrivo :
\begin{lstlisting}[style=java]
public class MainDate {
    public static void main(String[] args){
        Date d1;
        Date d2;
        d1 = new Date();
        d2 = new Date();
        System.out.println(d1.day); // mando in output day
    }
}
\end{lstlisting}
In output otterò 0 senza scrivere nulla,però qua non ho inizializzato nulla perchè?\\
Perche gli attributi non inizializzati tengono il valore di default 0 poi varia a seconda del tipo per bool è false,per int è o,per float/double è 0.0,per gli oggetti è NULL.
posso anche scriverci facendo cosi:
\begin{lstlisting}[style=java]
public class MainDate {
    public static void main(String[] args){
        Date d1;
        Date d2;
        d1 = new Date();
        d2 = new Date();
        d1.day = 11;
        d1.month = 10;
        d1.year = 2021;
        System.out.println(d1.day);
    }
}
\end{lstlisting}
\subsection{Attributi}
Se mando in esecuzione effettivamente mi stampa il giorno però questo modo di scrittura ricorda molto il C ma quindi \textbf{ non è a oggetti}.
Pensiamo al termine di \textbf{incapsulazione} che ci dice che serve per "nascondere" i dettagli di un oggetto,noi invece stiamo violando una regola della programmazione ad oggetti\\
Ma com'è possibile che MainDate acceda direttamente agli attributi?\\
Bisognerebbe dichiarare gli oggetti private in questo modo : 
\begin{lstlisting}[style=java]
public class Date {
    // Attributi
    private int day;
    private int month;
    private int year;
}
\end{lstlisting}
Di default gli attributi sono \textbf{public}.\\
\subsection{Costruttore}
Sorge un'altro problema ovvero e ora come li richiamiamo nel main??\\
Si utilizza quello che viene detto \textbf{costruttore} ovvero un qualcosa che serve per creare oggetti della classe definita.
Esso si chiama riscrivendo il nome della classe,invece all'interno delle parentesi tonde servono gli elementi che devi dichiarare \textbf{PER FORZA} per creare quel tipo di oggetto
\begin{lstlisting}[style=java]
public class Date {
    // Attributi
    private int day;
    private int month;
    private int year;

    // costruttore
    public Date(int d,int m,int y){
        this.day = d;
        this.month = m;
        this.year = y;
    }
}
\end{lstlisting}
NB. this non serve per forza chiamarlo però se non ci fosse si potrebbe creare ambiguità\\
E quindi ora MainDate per compilare deve essere cosi:
\begin{lstlisting}[style=java]
public class MainDate {
    public static void main(String[] args){
        Date d1;
        Date d2;
        d1 = new Date(11,10,2021);
        d2 = new Date(13,1,2022);
    }
}
\end{lstlisting}
\subsection{Metodi}
Ora pero vogliamo anche aver la possibilità di stampare,essendo che gli attributi sono private ce bisogno di un nuovo \textbf{metodo}.
Allora facciamo in questo modo prendendo il file della classe:
\begin{lstlisting}[style=java]
public class Date {
    // Attributi
    private int day;
    private int month;
    private int year;

    // costruttore
    public Date(int d,int m,int y){
        this.day = d;
        this.month = m;
        this.year = y;
    }

    //metodi
    public String toString(){
        String result = this.day + "/" + this.month + "/" + this.year;
        return result;
    }
}
\end{lstlisting}
\subsection{Stampare un Oggetto toString()}
Ora Proviamo a chiamare i metodi nel file MainDate in questo modo:
\begin{lstlisting}[style=java]
public class MainDate {
    public static void main(String[] args){
        Date d1;
        Date d2;
        d1 = new Date(11,10,2021);
        d2 = new Date(13,1,2022);
        String s1;
        s1 = d1.toString();
        System.out.println(s1);
    }
}
\end{lstlisting}
Facendo così avremmo in output 11/10/2021.\\
NB nei linguaggi tradizionali vengono posti gli attributi in maniera implicita ovvero passarli direttamente al metodo invece qua in Java si mette in maniera esplicita.\\
In Java però ce una cosa figa se tu chiami il metodo toString() puoi fare anche una roba del genere:
\begin{lstlisting}[style=java]
public class MainDate {
    public static void main(String[] args){
        Date d1;
        Date d2;
        d1 = new Date(11,10,2021);
        d2 = new Date(13,1,2022);
        String s1;
        s1 = d1.toString();
        System.out.println(s1);
        System.out.println(s2);// sottointeso d2.toString()
    }
}
\end{lstlisting}
Come si puo vedere s2 verrà lo stesso stampata perchè viene sottointeso se presente il metodo toString().
\subsection{Comparare un oggetto che ho creato:}
Come detto nei capitoli precedenti in Java usare l'operatore == con dei oggetti non ha senso perchè confronterà la loro zona di memoria.
Allora creo un metodo che solitamente è chiamato equals(); in questo modo:
\begin{lstlisting}[style=java]
public class Date {
    // Attributi
    private int day;
    private int month;
    private int year;

    // costruttore
    public Date(int d,int m,int y){
        this.day = d;
        this.month = m;
        this.year = y;
    }

    //metodi
    public String toString(){
        String result = this.day + "/" + this.month + "/" + this.year;
        return result;
    }
    public boolean equals(Date other){
        boolean result = this.day == other.day && this.month == other.month && this.year == other.year;
        return result;
    }
}
\end{lstlisting}
Come possiamo notare dal codice sopra capiamo che other specifica tutti gli attributi di un classe.
Ora utilizziamo questo metodo nel main in questo modo:
\begin{lstlisting}[style=java]
public class MainDate {
    public static void main(String[] args){
        Date d1;
        Date d2;
        d1 = new Date(11,10,2021);
        d2 = new Date(13,1,2022);
        d3 = new Date(13,1,2022);
        String s1;
        s1 = d1.toString();
        System.out.println(s1);
        System.out.println(s2);// sottointeso d2.toString()
        boolean b1 = (d1.equals(d2));
        System.out.println(b1);
        boolean b2 = (d2.equals(d3));
        System.out.println(b2);
    }
}
\end{lstlisting}
Facendo così notiamo che b1 giustamente è uguale a false invece b2 è uguale a true.
\subsection{Compariamo due oggetti}
Per lo stesso motivo di prima anche comparare due oggetti normalmente usando l'operatore $>$ non ha senso allora si dovra creare un nuovo metodo in questo modo:
\begin{lstlisting}[style=java]
public class Date {
    // Attributi
    private int day;
    private int month;
    private int year;

    // costruttore
    public Date(int d,int m,int y){
        this.day = d;
        this.month = m;
        this.year = y;
    }

    //metodi
    public String toString(){
        String result = this.day + "/" + this.month + "/" + this.year;
        return result;
    }
    public boolean equals(Date other){
        boolean result = this.day == other.day && this.month == other.month && this.year == other.year;
        return result;
    }
    //convenzione(visto che uso int):
    //<0 : this viene prima di other
    //>0 : this viene dopo other
    //== 0 : this e other coincidono cronologicamente
    public int compareTo(Date other){
        if(year<other.year){
            return -1;
        }else if(year>other.year){
            return 1;
        }else if (month<other.month){
            return -1;
        }else if(month>other.month){
            return 1;
        }else if(day<other.day){
            return -1
        }else if(day>other.day){
            return 1;
        }else{
            return 0;
        }
    }
}
\end{lstlisting}
Creando un oggetto del genere e richiamando il metodo nel main otterò l'effetto di una comparazione.
